(ns sq.quotes
  (:require 
    [clojure.core.async :refer [<! >! chan go-loop timeout]]
    [clojure.data.json :as json]
    [clojure.tools.logging :as log]
    [clj-time.core :as time]
    [clj-time.format :as fmt]))

(defn get-comma-separated-symbols [config] 
  (apply str (interpose "," (map (fn [s] (:symbol s)) (:stocks config))))
)

(defn get-lookup-url [config]
  ; Ignoring url encoding issues, cap on number of symbols that can be looked up and the url length for now
  (str "http://finance.yahoo.com/webservice/v1/symbols/" (get-comma-separated-symbols config) "/quote?format=json")
)

(defn get-raw-quotes [config]
  ; Make web requets and then convert to json - migth be possible to do this in one step
  (json/read-str (slurp (get-lookup-url config)))
)

(defn parse-raw-quote [quote]
  ; Destructure
  ; 	fields var as "resources" internal map and then its "fields" internal map
  ;	name, symbol, price and utctime vars from within the just destructured fields var
  ; Return a new map with just the data we need
  (let [fields (get-in quote ["resource" "fields"]) 
        {:strs [name symbol price utctime]} fields]
    {:name name :symbol symbol :price price :timestamp (fmt/parse (fmt/formatters :date-time-no-ms) utctime)}
  )
)

(defn get-quotes [config]
  ; Get raw quotes
  ; Destructure quotes var as "list" internal map and then its "resources" internal map
  ; Return a vector of quote data
  (let [raw-quotes (get-raw-quotes config)
        {{quotes "resources"} "list"} raw-quotes]
    (vec (map parse-raw-quote quotes))
  )
)

(defn watch-quotes [config]
  (let [out (chan)
        stocks-count (count (:stocks config))
        pause-interval (* (:refresh-interval-seconds config) 1000)]
    (if (> stocks-count 0)
      (go-loop []
        ; Put quotes on out channel and pause
        (>! out (get-quotes config))
        (<! (timeout pause-interval))
        (recur)
      )
      (log/info "No stocks to watch")
    )
    out
  )
)
